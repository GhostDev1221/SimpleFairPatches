---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2018/11/5 10:05
---
require "messages.Messages"
require "base.messages.IMessages"
require "base.util.MsgSender"
require "base.util.json"
require "base.util.DateUtil"
require "base.web.WebService"
require "config.ActorNpcConfig"
require "config.ShopConfig"
require "base.util.uuid"
require "util.RewardUtil"
require "util.BackHallManager"
require "util.DBUtil"

GameMatch = {}

GameMatch.gameType = "g1039"
GameMatch.curTick = 0
GameMatch.gameAssignRoleTick = 0
GameMatch.gameWaitTick = 0
GameMatch.gameChangeActorTick = 0
GameMatch.gameStartTick = 0
GameMatch.sneerStartTick = 0
GameMatch.gameOverTick = 0

GameMatch.Status = {}
GameMatch.Status.Init = 0
GameMatch.Status.WaitingPlayer = 1
GameMatch.Status.AssignRole = 2
GameMatch.Status.ChangeActor = 3
GameMatch.Status.Running = 4
GameMatch.Status.GameOver = 5
GameMatch.Status.CloseServer = 6
GameMatch.curStatus = GameMatch.Status.Init

GameMatch.isFirstReady = false
GameMatch.isReward = false
GameMatch.sneerNum = 4
GameMatch.winRole = 0

GameMatch.seekNum = 0
GameMatch.hideNum = 0
GameMatch.timerList = {}

function GameMatch:initMatch()
    GameTimeTask:start()
end

function GameMatch:onTick(ticks)
    self.curTick = ticks
    self:invokeTimer()
    self:ifUpdateRank()
    --DBUtil:saveAllPlayerData()
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        v:invokeTimer()
    end

    if self.curStatus == self.Status.WaitingPlayer then
        self:ifStartAssignRole()
    end

    if self.curStatus == self.Status.AssignRole then
        self:ifAssignRoleEnd()
    end

    if self.curStatus == self.Status.ChangeActor then
        self:ifGameStart()
    end

    if self.curStatus == self.Status.Running then
        self:ifGameOver()
    end

    if self.curStatus == self.Status.GameOver then
        self:ifGameOverEnd()
    end

    if self.curStatus == self.Status.CloseServer then
        ReportManager:closeServer()
    end

    if self.curTick - self.gameStartTick >= GameConfig.sneerBeginTime and self:isGameStart() then
        self:sneerSeeks()
    end

    BackHallManager:onTick()
end

function GameMatch:sneerSeeks()
    local roundTime = GameConfig.sneerKeepTime + GameConfig.sneerSilentTime
    local seconds = self.curTick - self.gameStartTick - GameConfig.sneerBeginTime
    local players = PlayerManager:getPlayers()
    if seconds % roundTime == 0 then
        self:sneerCountDown(GameConfig.sneerKeepTime)
        HostApi.sendPlaySound(0, 10034)
        for i, v in pairs(players) do
            if v.role == GamePlayer.ROLE_HIDE and v.isLife == true then
                v:sneer(1)
            end
        end
    end
end

function GameMatch:silentCountDown(time)
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        if v.role == GamePlayer.ROLE_HIDE and v.isLife == true then
            v.entityPlayerMP:showBossStripWithIcon("haschase.key.silent", time, GameConfig.sneerSilentTime, "set:chase.json image:idle")
        end
    end
    self:startTimer(1, function()
        if time < GameConfig.sneerSilentTime - 1 then
            self:silentCountDown(time + 1)
        end
    end)
end

function GameMatch:sneerCountDown(time)
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        if v.role == GamePlayer.ROLE_HIDE and v.isLife == true then
            v.entityPlayerMP:showBossStripWithIcon("haschase.key.sneer", time, GameConfig.sneerKeepTime, "set:chase.json image:sneer")
        end
    end
    self:startTimer(1, function()
        if time <= GameConfig.sneerKeepTime and time > 0 then
            self:sneerCountDown(time - 1)
        elseif time == 0 then
            self:silentCountDown(1)
        end
    end)
end


function GameMatch:getLifeTeams()
    local lifeTeam = 0
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        if v.role == GamePlayer.ROLE_SEEK and v.isLife then
            lifeTeam = lifeTeam + 1
        end
        if v.role == GamePlayer.ROLE_HIDE and v.isLife then
            lifeTeam = lifeTeam + 1
        end
    end
    return lifeTeam
end

function GameMatch:ifUpdateRank()
    if self.curTick % 300 == 0 and PlayerManager:isPlayerExists() then
        RankNpcConfig:updateRank()
    end
end
function GameMatch:startAssignRole()
    HostApi.sendGameStatus(0, 1)
    HostApi.sendStartGame(PlayerManager:getPlayerCount())
    self.isReward = false
    RewardManager:startGame()
    self.gameAssignRoleTick = self.curTick
    self.curStatus = self.Status.AssignRole
    ActorNpcConfig:prepareActorNpc()
    MsgSender.sendMsg(Messages:assignRoleTimeHint(GameConfig.assignRoleTime))
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        v.isInGame = true
    end
end

function GameMatch:getGameLastTime()
    return GameConfig.gameTime - (self.curTick - self.gameStartTick)
end

function GameMatch:ifStartAssignRole()
    if PlayerManager:isPlayerEnough(GameConfig.startPlayers) then
        if self.isFirstReady then
            MsgSender.sendMsg(IMessages:msgCanStartGame())
            MsgSender.sendMsg(IMessages:msgGameStartTimeHint(GameConfig.prepareTime, IMessages.UNIT_SECOND, false))
            self.gameWaitTick = self.curTick
            self.isFirstReady = false
        end
        if self.curTick - self.gameWaitTick > GameConfig.prepareTime then
            self:startAssignRole()
        else
            local seconds = GameConfig.prepareTime - (self.curTick - self.gameWaitTick)
            if seconds <= 10 and seconds > 0 then
                MsgSender.sendBottomTips(3, IMessages:msgGameStartTimeHint(seconds, IMessages.UNIT_SECOND, false))
                if seconds <= 3 then
                    HostApi.sendPlaySound(0, 12)
                else
                    HostApi.sendPlaySound(0, 11)
                end
            end
            if seconds == 3 then
                HostApi.sendStartGame(PlayerManager:getPlayerCount())
            end
        end
    else
        if self.curTick % 30 == 0 then
            MsgSender.sendMsg(IMessages:msgWaitPlayer())
            MsgSender.sendMsg(IMessages:msgGamePlayerNum(PlayerManager:getPlayerCount(), GameConfig.startPlayers))
        end
        self.isFirstReady = true
    end
end

function GameMatch:assignRole()
    local players = PlayerManager:getPlayers()
    local playernum = #players
    if playernum < 1 then
        return false
    end
    local seeks = math.floor((playernum * 4 / 9)  + 0.5)
    for i, v in pairs(players) do
        if v.role == GamePlayer.ROLE_PENDING then
            math.randomseed(os.clock() * 1000000)
            local random = math.random(1, playernum)
            if random <= seeks then
                if v.multiSeek < 1 then
                    if v:becomeRole(GamePlayer.ROLE_SEEK) then
                        seeks = seeks - 1
                        playernum = playernum - 1
                        self.seekNum = self.seekNum + 1
                    end
                end
            else
                if v:becomeRole(GamePlayer.ROLE_HIDE) then
                    playernum = playernum - 1
                    self.hideNum = self.hideNum + 1
                end
            end
        end
    end
    self:teleRolePos()
    self:rebuildShowName()
    self:sendAllPlayerTeamInfo()
    return true
end

function GameMatch:startTimer(time, callback)
    local item = {}
    item.time = time
    item.callback = callback
    table.insert(self.timerList, item)
end

function GameMatch:invokeTimer()
    if self.timerList ~= nil then
        for i, timer in pairs(self.timerList) do
            timer.time = timer.time - 1
            if timer.time <= 0 and type(timer.callback) == "function" then
                timer.callback()
                table.remove(self.timerList, i)
            end
        end
    end
end

function GameMatch:clearTimer()
    if self.timerList ~= nil then
        for i, timer in pairs(self.timerList) do
                table.remove(self.timerList, i)
        end
    end
end

function GameMatch:sendAllPlayerTeamInfo()
    local result = {}
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        if v.isInGame then
            local item = {}
            item.userId = tonumber(tostring(v.userId))
            item.teamId = v.role
            table.insert(result, item)
        end
    end
    HostApi.sendPlayerTeamInfo(json.encode(result))
end

function GameMatch:rebuildShowName()
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        v:sendBuildShowName(players)
    end
end

function GameMatch:teleRolePos()
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        v:teleRolePos()
    end
end

function GameMatch:onPlayerLive(ticks)
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        v:onLive(ticks)
    end
end

function GameMatch:onPlayerQuit(player)
    player:onDie()
    self:resetRoleNum(player.role)
    self:ifGameOverByPlayer()
end

function GameMatch:resetRoleNum(role)
    if role == GamePlayer.ROLE_HIDE then
        self.hideNum = self.hideNum - 1
    else
        self.seekNum = self.seekNum - 1
    end
end

function GameMatch:ifGameOverByPlayer()
    if self.hideNum == 0 and self.seekNum ~= 0 then
        self:seekWin()
    elseif self.seekNum == 0 then
        self:hideWin()
    end
end

function GameMatch:ifGameOverEnd()
    local ticks = self.curTick - self.GameOverTick
    local seconds = GameConfig.gameOverTime - ticks
    HostApi.syncGameTimeShowUi(0, false, 0)
    MsgSender.sendBottomTips(3, IMessages:msgCloseServerTimeHint(seconds))
    if seconds <= 0 then
        self:doGameOverEnd()
    end
end

function GameMatch:doGameOverEnd()
    self.curStatus = self.Status.CloseServer
    local players = PlayerManager:copyPlayers()
    for _, player in pairs(players) do
        player:overGame(self.winRole)
    end
    players = PlayerManager:getPlayers()
    RewardUtil:doReport(players)
end

function GameMatch:ifGameOver()
    local ticks = self.curTick - self.gameStartTick
    local seconds = GameConfig.gameTime - ticks
    self:onPlayerLive(ticks)

    if seconds % 60 == 0 and seconds / 60 > 0 then
        MsgSender.sendMsg(IMessages:msgGameEndTimeHint(seconds / 60, IMessages.UNIT_MINUTE, false))
        if seconds <= 10 and seconds > 0 then
            MsgSender.sendBottomTips(3, IMessages:msgGameEndTimeHint(seconds, IMessages.UNIT_SECOND, false))
            if seconds <= 3 then
                HostApi.sendPlaySound(0, 12)
            else
                HostApi.sendPlaySound(0, 11)
            end
        end
    end
    if seconds == GameConfig.invincibleTime then
        local players = PlayerManager:getPlayers()
        for i, player in pairs(players) do
            if player.role == GamePlayer.ROLE_SEEK then
                player:subGunFireCd()
            end
        end
        MsgSender.sendMsg(Messages:last45Second())
        MsgSender.sendCenterTips(3, Messages:last45Second())
    end
    if seconds <= 0 then
        self:hideWin()
    end
end

function GameMatch:hideWin()
    self.GameOverTick = self.curTick
    self.winRole = GamePlayer.ROLE_HIDE
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        if v.role == GamePlayer.ROLE_HIDE and v.isLife == true then
            v.hideTime = os.clock()
            v.entityPlayerMP:showBossStripWithIcon("", 0, 0, " ")
        end
    end
    self:clearTimer()
    if not self.isReward then
        self.isReward = true
        self.gameOverTick = self.curTick
        self.curStatus = self.Status.GameOver
        MsgSender.sendMsg(IMessages:msgWinnerInfo(Messages:getRoleName(GamePlayer.ROLE_HIDE)))
        for j, v in pairs(players) do
            --v:onGameEnd(GamePlayer.ROLE_HIDE)
            if v.role == GamePlayer.ROLE_HIDE then
                v:onWin()
            end
            RankNpcConfig:savePlayerRankScore(v)
        end
        RewardUtil:doReward(GamePlayer.ROLE_HIDE)
        --DBUtil:saveAllPlayerData()
    end
end

function GameMatch:seekWin()
    self.GameOverTick = self.curTick
    self.winRole = GamePlayer.ROLE_SEEK
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        if v.role == GamePlayer.ROLE_HIDE and v.isLife == true then
            v.entityPlayerMP:showBossStripWithIcon("", 0, 0, " ")
        end
    end
    self:clearTimer()
    if not self.isReward then
        self.isReward = true
        self.gameOverTick = self.curTick
        self.curStatus = self.Status.GameOver
        MsgSender.sendMsg(IMessages:msgWinnerInfo(Messages:getRoleName(GamePlayer.ROLE_SEEK)))
        for j, v in pairs(players) do
            --v:onGameEnd(GamePlayer.ROLE_SEEK)
            if v.role == GamePlayer.ROLE_SEEK then
                v:onWin()
            end
            RankNpcConfig:savePlayerRankScore(v)
        end
        RewardUtil:doReward(GamePlayer.ROLE_SEEK)
        --DBUtil:saveAllPlayerData()
    end
end

function GameMatch:ifAssignRoleEnd()
    local seconds = GameConfig.assignRoleTime - (self.curTick - self.gameAssignRoleTick)

    if seconds <= 10 and seconds > 0 then
        MsgSender.sendBottomTips(3, Messages:assignRoleTimeHint(seconds, IMessages.UNIT_SECOND, false))
        if seconds <= 3 then
            HostApi.sendPlaySound(0, 12)
        else
            HostApi.sendPlaySound(0, 11)
        end
    end

    if seconds <= 0 then
        self:hideHide()
        self:assignRoleEnd()
    end
end

function GameMatch:hideHide()
    local players = PlayerManager:getPlayers()
    for i, p1 in pairs(players) do
        for j, p2 in pairs(players) do
            if p1.role ~= p2.role then
                p1:changeInvisible(p2.rakssid, true)
            end
        end
    end
    return true
end

function GameMatch:showHide()
    local players = PlayerManager:getPlayers()
    for i, p1 in pairs(players) do
        for j, p2 in pairs(players) do
            if p1.role ~= p2.role then
                p1:changeInvisible(p2.rakssid, false)
            end
        end
    end
end

function GameMatch:assignRoleEnd()
    if self:assignRole() then
        self.gameChangeActorTick = self.curTick
        self.curStatus = self.Status.ChangeActor
        MsgSender.sendMsg(IMessages:msgGameStart())
        self:showChangeAndHideHint(GameConfig.changeActorTime)
        HostApi.sendPlaySound(0, 10019)
    else
        self:GameOver()
    end
end

function GameMatch:showChangeAndHideHint(seconds)
    local players = PlayerManager:getPlayers()
    for i, v in pairs(players) do
        if v.role == GamePlayer.ROLE_HIDE then
            if seconds > 10 then
                MsgSender.sendMsgToTarget(v.rakssid, Messages:changeAndHideHint(seconds))
            else
                MsgSender.sendBottomTipsToTarget(v.rakssid, seconds, Messages:changeAndHideHint(seconds))
            end
        elseif v.role == GamePlayer.ROLE_SEEK then
            if seconds > 10 then
                MsgSender.sendMsgToTarget(v.rakssid, Messages:waitChangeAndHideHint(seconds))
            else
                MsgSender.sendBottomTipsToTarget(v.rakssid, seconds, Messages:waitChangeAndHideHint(seconds))
            end
        end
    end
end

function GameMatch:isGameOver()
    return self.curStatus == self.Status.GameOver
end

function GameMatch:isChangeModel()
    return self.curStatus == self.Status.ChangeActor
end

function GameMatch:isCanChangeModel()
    return self.curStatus > self.Status.AssignRole
end

function GameMatch:ifGameStart()
    local seconds = GameConfig.changeActorTime - (self.curTick - self.gameChangeActorTick)
    self:showHide()
    if seconds <= 10 and seconds > 0 then
        self:showChangeAndHideHint(seconds)
        if seconds <= 3 then
            HostApi.sendPlaySound(0, 12)
        else
            HostApi.sendPlaySound(0, 11)
        end
    end

    if seconds <= 0 then
        self:startGame()
    end
end

function GameMatch:startGame()
    self.gameStartTick = self.curTick
    self.curStatus = self.Status.Running
    local players = PlayerManager:getPlayers()
    for i, player in pairs(players) do
        player:setSpeedAddition(player.speedLevel)
    end
    MsgSender.sendCenterTipsToTarget(0, 3, Messages:goStartGame())
    AreaOfEliminateConfig:destoryAreaOfEliminate()
    HostApi.syncGameTimeShowUi(0, true, GameConfig.gameTime)
end

function GameMatch:GameOver()
    GameTimeTask:pureStop()
end

function GameMatch:isGameStart()
    return self.curStatus == self.Status.Running
end

function GameMatch:ifGameEnd()
    return self.curStatus == self.Status.GameOver
end

return GameMatch