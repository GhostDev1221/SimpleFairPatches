---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2018/12/22 17:24
---

require "base.util.class"

BaseProcess = class()

BaseProcess.curTick = 0

BaseProcess.Status = {}
BaseProcess.Status.Init = 0
BaseProcess.Status.Waitting = 1
BaseProcess.Status.Prepare = 2
BaseProcess.Status.Running = 3
BaseProcess.Status.ExtraTime = 4
BaseProcess.Status.GameOver = 5
BaseProcess.Status.WaitClose = 6
BaseProcess.curStatus = 0

BaseProcess.PrepareTick = 0
BaseProcess.RunningTick = 0
BaseProcess.ExtraTick = 0
BaseProcess.GameOverTick = 0
BaseProcess.WaitCloseTick = 0

function BaseProcess:onTick(ticks)
    self.curTick = ticks

    if self.curStatus == self.Status.Waitting then
        self:ifWaittingEnd()
    end

    if self.curStatus == self.Status.Prepare then
        self:ifPrepareEnd()
    end

    if self.curStatus == self.Status.Running then
        self:ifGameEnd()
    end

    if self.curStatus == self.Status.ExtraTime then
        self:ifExtraTimeEnd()
    end

    if self.curStatus == self.Status.GameOver then
        self:ifGameOverEnd()
    end

    if self.curStatus == self.Status.WaitClose then
        self:ifWaitCloseEnd()
    end

end

function BaseProcess:ifWaittingEnd()
    --waitting --> prepare
    if PlayerManager:isPlayerEnough(GameConfig.startPlayers) then
        self:waittingEnd()
    else
        if self.curTick % 5 == 0 then
            MsgSender.sendMsg(IMessages:msgWaitPlayer())
            MsgSender.sendMsg(IMessages:msgGamePlayerNum(PlayerManager:getPlayerCount(), GameConfig.startPlayers))
        end
    end
end

function BaseProcess:waittingEnd()
    self.PrepareTick = self.curTick
    self.curStatus = self.Status.Prepare
end

function BaseProcess:ifPrepareEnd()
    --prepare --> running
    local seconds = GameConfig.prepareTime - (self.curTick - self.PrepareTick)

    if seconds == 45 or seconds == 30 then
        MsgSender.sendMsg(IMessages:msgGameStartTimeHint(seconds, IMessages.UNIT_SECOND, false))
    end

    if seconds <= 10 and seconds > 0 then
        MsgSender.sendBottomTips(3, IMessages:msgGameStartTimeHint(seconds, IMessages.UNIT_SECOND, false))
        if seconds <= 3 then
            HostApi.sendPlaySound(0, 12)
        else
            HostApi.sendPlaySound(0, 11)
        end
        if seconds == 1 then
            self:clearAllPlayerInv()
        end
    end

    if seconds <= 0 then
        self:doPrepareEnd()
    end
end

function BaseProcess:clearAllPlayerInv()
    local players = PlayerManager:getPlayers()
    for _, player in pairs(players) do
        player:clearInv()
    end
end

function BaseProcess:doPrepareEnd()
    self.curStatus = self.Status.Running
    self.RunningTick = self.curTick
    RewardManager:startGame()
    self:prepareGame()
    HostApi.sendStartGame(PlayerManager:getPlayerCount(), true)
    MsgSender.sendMsg(Messages:msgGameStartTip())
end

function BaseProcess:prepareGame()
    HostApi.setAutoShootEnable(0, true)
    local players = PlayerManager:getPlayers()
    for _, player in pairs(players) do
        self:teleGamePos(player)
        player:initEquipItems()
    end
end

function BaseProcess:ifGameEnd()
    --running --> gameover/extratime
    local ticks = self.curTick - self.RunningTick

    local seconds = GameConfig.gameTime - ticks
    local players = PlayerManager:getPlayers()
    for i, player in pairs(players) do
        player:onTick()
    end
    GameMatch.Process:showGameInfo(seconds)
    if seconds % 60 == 0 and seconds / 60 > 0 then
        MsgSender.sendMsg(IMessages:msgGameEndTimeHint(seconds / 60, IMessages.UNIT_MINUTE, false))
    end

    if seconds <= 10 and seconds > 0 then
        MsgSender.sendBottomTips(3, IMessages:msgGameEndTimeHint(seconds, IMessages.UNIT_SECOND, false))
        if seconds <= 3 then
            HostApi.sendPlaySound(0, 12)
        else
            HostApi.sendPlaySound(0, 11)
        end
    end

    if seconds == GameConfig.finalTime then
        HostApi.sendStartGame(PlayerManager:getPlayerCount())
    end

    if seconds <= 0 then
        self:doWin()
    end
end

function BaseProcess:doWin()

end

function BaseProcess:ifExtraTimeEnd()
    --extratime --> gameover
end

function BaseProcess:ifGameOverEnd()
    --gameover
    local ticks = self.curTick - self.GameOverTick

    local seconds = GameConfig.gameOverTime - ticks

    if seconds <= 0 then
        self:doGameOverEnd()
    end
    MsgSender.sendBottomTips(3, IMessages:msgCloseServerTimeHint(seconds))
end

function BaseProcess:doGameOverEnd()
    self.curStatus = self.Status.WaitClose
    self.WaitCloseTick = self.curTick
    local players = PlayerManager:getPlayers()
    for i, player in pairs(players) do
        HostApi.sendGameover(player.rakssid, IMessages:msgGameOver(), GameOverCode.GameOver)
    end
end

function BaseProcess:ifWaitCloseEnd()
    if self.curTick - self.WaitCloseTick >= 10 then
        self:doWaitCloseEnd()
    end
end

function BaseProcess:doWaitCloseEnd()
    GameTimeTask:pureStop()
    ReportManager:closeServer()
end

function BaseProcess:onPlayerQuit(player)

end

function BaseProcess:isRunning(...)
    return self.curStatus == self.Status.Running
            or self.curStatus == self.Status.ExtraTime
end

function BaseProcess:isGameEnd()
    return self.curStatus == self.Status.GameOver
end

function BaseProcess:ifClose()
    if PlayerManager:isPlayerEmpty() then
        self:doGameOverEnd()
    end
end

function BaseProcess:onPlayerRespawn(player)
    self:teleGamePos(player)
end

function BaseProcess:teleGamePos(player)

end

function BaseProcess:onPlayerKill(player)

end

function BaseProcess:showGameInfo(time)

end

function BaseProcess:assignTeam(player)

end

function BaseProcess:ifPlayerWin()

end

function BaseProcess:ifRevenge()

end

function BaseProcess:resetSite()

end

function BaseProcess:reset()

end

function BaseProcess:isSelect(id)

end

function BaseProcess:updateSite(ticks)

end

function BaseProcess:changeSite(player)

end

function BaseProcess:updateChest(id)

end

function BaseProcess:sortPlayers(players)
    table.sort(players, function(p1, p2)
        if p1.kills ~= p2.kills then
            return p1.kills > p2.kills
        end
        return p1.userId < p2.userId
    end)
end

function BaseProcess:isGameOver(player)
    return self.curStatus > self.Status.ExtraTime
end

function BaseProcess:buildShowName(player)
    local nameList = {}
    local nameListNum = 1

    -- title
    if player.staticAttr.title ~= nil then
        nameList[nameListNum] = player.staticAttr.title
        nameListNum = nameListNum + 1
    end

    if player.staticAttr.role ~= -1 then
        local clanTitle = TextFormat.colorGreen .. player.staticAttr.clanName
        if player.staticAttr.role == 0 then
            clanTitle = clanTitle .. TextFormat.colorWrite .. "[Member]"
        end
        if player.staticAttr.role == 10 then
            clanTitle = clanTitle .. TextFormat.colorRed .. "[Elder]"
        end
        if player.staticAttr.role == 20 then
            clanTitle = clanTitle .. TextFormat.colorOrange .. "[Chief]"
        end
        nameList[nameListNum] = clanTitle
        nameListNum = nameListNum + 1
    end

    local disName = TextFormat.colorWrite .. player.name
    if player:isGameVip() then
        disName = TextFormat.colorGold .. "[VIP]" .. disName
    end

    nameList[nameListNum] = disName
    nameListNum = nameListNum + 1

    local showName
    for _, name in pairs(nameList) do
        local lineName = name
        if (showName == nil) then
            showName = lineName
        else
            showName = showName .. "\n" .. lineName;
        end
    end
    return showName
end

function BaseProcess:isGameBegin()
    return self.curStatus > self.Status.Prepare
end

return BaseProcess
