---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Jimmy.
--- DateTime: 2019/2/15 0015 11:47
---
local TaskType = {
    Undefine = 0,
    Delay = 1,
    Period = 2,
    DelayAndPeriod = 3,
    PeriodTimer = 4
}

LuaTimer = {}
LuaTimer.CurTaskKey = 0
LuaTimer.Tasks = {}

function LuaTimer:onTick()
    local time = os.time()
    local removes = {}
    for key, task in pairs(LuaTimer.Tasks) do
        if task.type == TaskType.Delay then
            if time - task.time >= task.delay then
                task.action(unpack(task.params, 1))
                table.insert(removes, key)
            end
        end
        if task.type == TaskType.Period then
            if time - task.time >= task.period then
                task.action(unpack(task.params, 1))
                task.time = time
            end
        end
        if task.type == TaskType.DelayAndPeriod then
            if task.delay >= 0 then
                if time - task.time >= task.delay then
                    task.action(unpack(task.params, 1))
                    task.time = time
                    task.delay = -1
                end
            else
                if time - task.time >= task.period then
                    task.action(unpack(task.params, 1))
                    task.time = time
                end
            end
        end
        if task.type == TaskType.PeriodTimer then
            if task.times >= 0 then
                if task.times == 0 then
                    table.insert(removes, key)
                else
                    if time - task.time >= task.period then
                        task.action(unpack(task.params, 1))
                        task.time = time
                        task.times = task.times - 1
                    end
                end
            else
                if time - task.time >= task.period then
                    task.action(unpack(task.params, 1))
                    task.time = time
                end
            end
        end
    end
    for _, key in pairs(removes) do
        LuaTimer:cancel(key)
    end
end

function LuaTimer:schedule(action, delay, period, ...)
    assert(action ~= nil, "[LuaTimer] action is nil.")
    assert(delay ~= nil or period ~= nil, "[LuaTimer] delay and period is nil.")
    local task = {
        action = action,
        type = TaskType.Undefine,
        times = 0,
        delay = 0,
        period = 0,
        params = { ... },
        time = os.time()
    }
    if delay ~= nil and period == nil then
        assert(type(delay) == "number")
        task.type = TaskType.Delay
        task.delay = delay
    end
    if delay == nil and period ~= nil then
        assert(type(period) == "number")
        task.type = TaskType.Period
        task.period = period
    end
    if delay ~= nil and period ~= nil then
        assert(type(delay) == "number" and type(period) == "number")
        task.type = TaskType.DelayAndPeriod
        task.delay = delay
        task.period = period
    end
    LuaTimer.CurTaskKey = LuaTimer.CurTaskKey + 1
    local key = tostring(LuaTimer.CurTaskKey)
    LuaTimer.Tasks[key] = task
    return key
end

function LuaTimer:scheduleTimer(action, period, times, ...)
    assert(action ~= nil, "[LuaTimer] action is nil.")
    assert(period ~= nil, "[LuaTimer] period is nil.")
    times = times or -1
    local task = {
        action = action,
        type = TaskType.PeriodTimer,
        delay = 0,
        times = times,
        period = period,
        params = { ... },
        time = os.time()
    }
    LuaTimer.CurTaskKey = LuaTimer.CurTaskKey + 1
    local key = tostring(LuaTimer.CurTaskKey)
    LuaTimer.Tasks[key] = task
    return key
end

function LuaTimer:cancel(key)
    LuaTimer.Tasks[key] = nil
end

return LuaTimer